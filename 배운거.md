# 배운거

## Colocating Selectors with Reducer

```js
// visibleTodoList.js
...
import { getVisibleTodos } from 'Reducers/todos/'

const mapStateToProps = (state, { params }) => {
  todos: getVisibleTodos(state.todos, params.filter || 'all');
};
```

visibleTodos 를 가져오기 위해, getVisibleTodos라는 셀렉터를 사용한다.
이 때 전달되는 파라미터는 state.todos라는 조각이다.

이 때, state 구조가 바뀌면(정확히는 todos), getVisibleTodos함수를 사용하는 곳의 코드를 전부 변경해야한다.

그래서 public API와, private API로 나눠보자.

public API는

- 외부에서(컴포넌트에서) 접근 가능한 API
- 셀렉터를 사용하는쪽은 state만 전달해주면 된다. 즉, selector를 사용하는 컴포넌트는 selector를 사용하기 위해, 아무것도 몰라도됨. 걍 state만 전달하면된다.
  - 이렇게 하면, state 구조가 바뀌더라도 코드 변경 불필요하다.
  - 컴포넌트 측은 필요한 것을 얻기위해 어떠한 정보(어떤 state 조각을 넘겨야 할지)도 알필요 없이 state만 전달하면됨. (connect의 mapStateToProps 함수를 통해 전체 app 상태 정보를 알고있음)
- 이것은 rootReducer. 즉, 서브 리듀서들이 최종 통합되는 곳(`reducer/index`)에서 작성한다.

private API는

- 외부에서(컴포넌트에서) 접근 불가한 API
- 복잡한 로직(반복문을 통해 visible한 todo 찾기)은 private API에서 책임진다.

위와 같은 규칙을 통해 selector를 다시 작성해보자.

```js
// visibleTodoList.js
...
import { getVisibleTodos } from 'Reducers/'

const mapStateToProps = (state, { match: { params } }) => {
  const filter = params.filter || 'all';
  return {
    todos: getVisibleTodos(state, filter),
    filter,
  };
};
```

```js
// reducer/index.js
const todoApp = combineReducers({
  todos,
  visibilityFilter,
});

export default todoApp;

// public API
export const getVisibleTodos = (state, filter) => {
  return fromTodos.getVisibleTodos(state.todos, filter);
};
```

```js
// reducer/todos.js
// private API
export const getVisibleTodos = (state, filter) => {
  switch (filter) {
    case 'all':
      return state;
    case 'completed':
      return state.todos.filter(t => t.completed);
    case 'active':
      return state.todos.filter(t => !t.completed);
    default:
      throw new Error(`Unknown filter: ${filter}.`);
  }
};
```

`todos: getVisibleTodos(state, params.filter || 'all')` 이 구조를 만들어서

- state 구조가 변경되더라도 UI 를 사용하는 곳은 state 만 넣어주면 된다.
  - 왜냐하면 해당함수는 셀렉터 함수이기 때문이다.
  - 셀렉터 함수는 전체 어플리케이션 상태에 대한 정보를 알고 있고 해당 로직에 따라 state 만 넣어주면 select 해주기 때문이다.

## Nomarlizing the state shape

State tree 내부에서 `todo` objects의 배열을 todo로 나타낸다.

하지만 real world 에서는

- single array 이상일 수 있고,
- 다른 배열에서 동일한 id를 가진 todo와 sync가 맞지 않을 수도 있다.

```javascript
const todos = (state = [], action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, todo(undefined, action)];
    case 'TOGGLE_TODO':
      return state.map(t => todo(t, action));
    default:
      return state;
  }
};
```

### byId 리듀서 추가하기

**state를 db로 다루기, todos를 id에 의해 인덱싱된 obejct로 유지하기**

- reducer 를 `byID`로 리네이밍하기
- todo 추가 할 때 마지막 index에 추가하는 로직, todo toggle시에 map을 통해 상태 변경하는 로직을 사용하지 않고,

  - lookup table 내부의 값을 변경할 것이다.

`TOGGLE_TODO`와 `ADD_TODO`는 동일한 로직을 가진다.

(둘 다 룩업 테이블에서 key 값에 id 를 찾거나 추가, value 는 action 에서 태운 값)

`action.id`의 값이 이전 `action.id`값(`state[action.id]`)과

`action` 으로 todo reducer 를 호출한 결과(`todo(state[action.id], action)`)가 되도록 하는 new lookup table 을 리턴할거다.

아래 코드 중 이부분을 말한다. `[action.id]: todo(state[action.id], action),`

```javascript
const byId = (state = {}, action) => {
  switch (action.type) {
    case 'ADD_TODO':
    case 'TOGGLE_TODO':
      return {
        ...state,
        [action.id]: todo(state[action.id], action),
      };
    default:
      return state;
  }
};
```

### allIds reducer 추가하기

위에서 작성한 byId todos를 id를 키로 가지고 todo에 대한 정보를 값으로 가지는 map으로 유지한다. 

allIds 리듀서는 ADD_TODO만 신경쓴다.

그 이유는 new todo가 추가되면 new id를 가진 새로운 ids 배열을 리턴해야한다.(물론, 삭제 기능도 추가하면 얘도 포함..)

```js
const allIds = (state = [], action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.id];
    default:
      return state;
  }
};
```

2가지 리듀서 byId, allIds 를 생성했다.
이 리듀서는 todos.js에서 다시 comebine 된다.

### Updating getVisible Todos selector

reducer에서 state shape을 변경했다. 변경된 state shape을 의존하는 selector를 업데이트해보자.

todos의 배열을 더이상 사용하지 않기 때문에(위에서 우리가 normalize해서 state.todos 배열이 없어짐), 배열을 생성하는 `getAllTodos` 셀렉터를 만들자.

`getAllTodos`는 todos.js 에서만 사용하기 때문에 `allIds`와 `byId` lookup table 을 매핑한 결과를 리턴하자.

```js
const getAllTodos = state => state.allIds.map(id => state.byId[id]);
```

`getVisibleTodo` 셀렉터도 수정하자.

```js
export const getVisibleTodos = (state, filter) => {
  const allTodos = getAllTodos(state);
  switch (filter) {
    case 'all':
      return allTodos;
    case 'completed':
      return allTodos.filter(t => t.completed);
    case 'active':
      return allTodos.filter(t => !t.completed);
    default:
      throw new Error(`Unknown filter: ${filter}.`);
  }
};
```

`allTodos`는 컴포넌트가 예측하는 todos 의 배열이다. getVisibleTodos를 사용하는 측에서는 동일한 결과를 리턴해주기 때문에 바뀐 리듀서 및 state 구조에 대해 대응할 필요가 없다.

### 더 나아가서, todo라는 서브 리듀서로 리듀서 쪼개기

todos.js는 갱장히 커졌다. single todo를 관리하는 파일을 생성하자.

todo.js는 todos.js의 서브 리듀서다.

